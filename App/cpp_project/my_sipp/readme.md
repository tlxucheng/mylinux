2020-01-11

Core was generated by `./my_sipp -sn uas -trace_msg'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x000055859116b6ec in std::vector<message*, std::allocator<message*> >::size (this=0x18) at /usr/include/c++/7/bits/stl_vector.h:671
671           { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
(gdb) bt
#0  0x000055859116b6ec in std::vector<message*, std::allocator<message*> >::size (this=0x18) at /usr/include/c++/7/bits/stl_vector.h:671
#1  0x000055859116b4d3 in scenario::runInit (this=0x0) at scenario.cpp:151
#2  0x000055859116aa68 in main (argc=4, argv=0x7fff3cb556e8) at sipp.cpp:405

2020-01-11 17:40
加
        /*
        while (sockets_pending_reset.begin() != sockets_pending_reset.end()) {
            reset_connection(*(sockets_pending_reset.begin()));
            sockets_pending_reset.erase(sockets_pending_reset.begin());
        }
        */

        /* Update the clock. */
        getmilliseconds();
        /* Receive incoming messages */
        if(MODE_SERVER == sendMode)
    	{
    		pollset_process(running_tasks->empty());
    	}

client重传invite

2020-01-18
gdb sipp client信息
第一次 run  : screentask::run()
第二次 run  : bool watchdog::run()  
第三次 run  : bool CallGenerationTask::run()      call_generation_task.cp:93
第三次 run  : bool call::run()                    call.cpp:1570                   执行完毕后，server收到invite消息，并回消息

修改CallGenerationTask::run(), socketowner.cpp没编译通过

2020-01-28
完成编译，待验证一次invite-200OK流程

2020-01-29
完善 call::send_scene，编译通过，待验证一次invite-200OK流程

2020-01-30
完善 SendingMessage::SendingMessage，编译通过，待验证一次invite-200OK流程

16:47 client能发送invite，但是server端收不到，invite消息可能有错误
17:53 client能发送invite，但是server端收不到，invite消息可能有错误，
      server端走到 empty_socket，recvfrom ret: 503, socket->ss_fd: 4, 产生crash, check_for_message 还没加
21:38 （1）get_listener 获取出来空指针，server端产生crash, 先去除 process_message 中的 listener_ptr -> process_incoming(msg, src)
      （2）增加 g_test_one_send 测试发现 server端收到的消息有
	       place this symlink by a static file or a different symlink.
			#
			# See man:systemd-resolved.service(8) for details about the supported modes of
			# operation for /etc/resolv.conf.

			nameserver 127.0.0.53
			options edns0
			search DHCP HOST
			
2020-01-31
21:38 (1) check_for_message 返回出的长度不是收到sip消息的真实长度
      (2) read_message 调用 check_for_message 返回一个非0的长度，导致 read_message 执行2次
	  (3) 当前代码强制在empty_socket将消息长度赋值成真实的sip消息长度


2020-02-01
11:32 去除g_test_one_send，消息会快速重传，缺少sipp 1s重传一次的逻辑
21:13 (1)server端第二次执行send_scene函数时crash
      (2)if(0 == test)  // 已替换了sipp的含义
		{
			/* If we are paused, then we need to wake up so that we properly go through the state machine. */
			paused_until = 0;
			msg_index = search_index;
			return next();
		}
		else
		{
			setPaused();
		}

		
2020-02-03
11:47 server端 running_tasks->begin() 为 NULL
16:13 server端可以发送180 200OK，但是client收到180和200 OK后还继续发送invite
18:07 不重传时 msg_index = 1 获取出来的 curmsg -> send_scheme 为空指针


2020-02-04
10:52 （1）加了 g_test_one_send 无法发送2次消息，暂时没有找到sipp是怎么只发送一次invite的（./sipp -sn uac 127.0.0.1 -m 1 -trace_msg -nr）
            client发送的180和200 OK
      （2）下一步研究一下sipp的socket实现方式。
	  （3） call.cpp:3340 加了//return next()，模式sipp client收不到 180


2020-02-08
18:06 运行
（1） CallGenerationTask::run()   	(delete)
  |92      {                                                                                                                                                             |
   |93          int calls_to_open = 0;                                                                                                                                    |
   |94                                                                                                                                                                    |
   |95          if (quitting) {                                                                                                                                           |
  >|96              delete this;                                                                                                                                          |
   |97              return false;                                                                                                                                         |
   |98          }   
  可保证只发送一次invite
（2）可能是没有 get_last_request_uri 和 get_last_header 导致发送的180和200 OK 不对
 





























