2020-01-11

Core was generated by `./my_sipp -sn uas -trace_msg'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x000055859116b6ec in std::vector<message*, std::allocator<message*> >::size (this=0x18) at /usr/include/c++/7/bits/stl_vector.h:671
671           { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
(gdb) bt
#0  0x000055859116b6ec in std::vector<message*, std::allocator<message*> >::size (this=0x18) at /usr/include/c++/7/bits/stl_vector.h:671
#1  0x000055859116b4d3 in scenario::runInit (this=0x0) at scenario.cpp:151
#2  0x000055859116aa68 in main (argc=4, argv=0x7fff3cb556e8) at sipp.cpp:405

2020-01-11 17:40
加
        /*
        while (sockets_pending_reset.begin() != sockets_pending_reset.end()) {
            reset_connection(*(sockets_pending_reset.begin()));
            sockets_pending_reset.erase(sockets_pending_reset.begin());
        }
        */

        /* Update the clock. */
        getmilliseconds();
        /* Receive incoming messages */
        if(MODE_SERVER == sendMode)
    	{
    		pollset_process(running_tasks->empty());
    	}

client重传invite

2020-01-18
gdb sipp client信息
第一次 run  : screentask::run()
第二次 run  : bool watchdog::run()  
第三次 run  : bool CallGenerationTask::run()      call_generation_task.cp:93
第三次 run  : bool call::run()                    call.cpp:1570                   执行完毕后，server收到invite消息，并回消息

修改CallGenerationTask::run(), socketowner.cpp没编译通过

2020-01-28
完成编译，待验证一次invite-200OK流程

2020-01-29
完善 call::send_scene，编译通过，待验证一次invite-200OK流程

2020-01-30
完善 SendingMessage::SendingMessage，编译通过，待验证一次invite-200OK流程

16:47 client能发送invite，但是server端收不到，invite消息可能有错误
17:53 client能发送invite，但是server端收不到，invite消息可能有错误，
      server端走到 empty_socket，recvfrom ret: 503, socket->ss_fd: 4, 产生crash, check_for_message 还没加
21:38 （1）get_listener 获取出来空指针，server端产生crash, 先去除 process_message 中的 listener_ptr -> process_incoming(msg, src)
      （2）增加 g_test_one_send 测试发现 server端收到的消息有
	       place this symlink by a static file or a different symlink.
			#
			# See man:systemd-resolved.service(8) for details about the supported modes of
			# operation for /etc/resolv.conf.

			nameserver 127.0.0.53
			options edns0
			search DHCP HOST
			
2020-01-31
21:38 (1) check_for_message 返回出的长度不是收到sip消息的真实长度
      (2) read_message 调用 check_for_message 返回一个非0的长度，导致 read_message 执行2次
	  (3) 当前代码强制在empty_socket将消息长度赋值成真实的sip消息长度


2020-02-01
11:32 去除g_test_one_send，消息会快速重传，缺少sipp 1s重传一次的逻辑
21:13 (1)server端第二次执行send_scene函数时crash
      (2)if(0 == test)  // 已替换了sipp的含义
		{
			/* If we are paused, then we need to wake up so that we properly go through the state machine. */
			paused_until = 0;
			msg_index = search_index;
			return next();
		}
		else
		{
			setPaused();
		}

		
2020-02-03
11:47 server端 running_tasks->begin() 为 NULL
16:13 server端可以发送180 200OK，但是client收到180和200 OK后还继续发送invite


































